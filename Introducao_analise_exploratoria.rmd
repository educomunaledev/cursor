---
title: "Curso"
output: 
  html_document: 
    toc: true
    df_print: default
date: "`r Sys.Date()`"
---

OBS: Para apresentar de tabelas e imagens fora do Markdown, vá para o Tools \> Global options \> R Markdown and unselect “Show output inline for all R Markdown documents”

# 1. Biblioteca e pacotes

```{r}
options(repos = c(CRAN = "https://cran.r-project.org"))  # For global mirror

# Baixar pacotes do CRAN para a biblioteca (Para descomentar, use Ctrl + Shift + C)
# install.packages("tidyverse")
# install.packages("skimr")
# install.packages("janitor")
# install.packages("esquisse")
# install.packages("ggthemes")
# install.packages("plotly")
# install.packages("gghighlight")
# install.packages("patchwork")
# install.packages("ggsci")

# Chamando os pacotes da biblioteca
library(tidyverse) #Metapacote 
library(skimr) #Diagnóstico de tabela
library(janitor) #Limpeza de tabelas
library(esquisse) #Plotagem de gráficos prática
library(ggthemes) #Temas de ggplot
library(plotly) #Gráficos interativos
library(patchwork) #Unir gráficos
library(gghighlight) #Marcar pontos e linhas 
library(ggsci) #Paleta de cores 
```

# 2. Operações básicas

```{r}
#Operações básicas -----

#Variáveis numéricas
x = 5
y = 7
z = y + x
multi = x * y
multi
```

```{r}
# Variáveis textuais (characters, string)
a = "Olá"
b = "Tudo bem?"
```

```{r}
# Variáveis Lógicas
t = TRUE
f = FALSE
tt = TRUE
ff = FALSE
aa = "Olá"
```

```{r}
# Comparações lógicas (booleanas)
t == f #Igual
t != f #Diferente
aa == a #Igual
a == b #Diferente

x < y # Menor
x > y # Maior
x <= 5 # menor ou igual
```

## Vetores

Os vetores são uma sequência unidimensional que podem ser números, strings, valores lógicos, entre outros.

```{r}
# Vetores
i = c(7, 5, 9, 10) #Numérico
i

j = c("Olá", "Caneta", "Qualificacao") #String
j

h = c(7, "olá", 78) #String
h

# O que esta função faz? Use o "?" antes da função e rode.
?c()
```

## Dataframes e tibbles

Dataframes e tibbles são tabelas comuns e consistem de linhas e colunas de diferentes classes, como números, caracteres e fatores.

As **tibbles são diferentes dos dataframes** somente em sua apresentação no console e facilitam muito o trabalho com tabelas grandes e largas.

Além disso, a criação do dataframe e da tibble são diferentes visualmente. Veja como a tibble é mais semelhante à forma que imputamos dados no excel.

Para criar um dataframe, usamos a função data.frame().

```{r}
#Dataframes e tibbles -----

#Dataframe
data = data.frame(
  nome = c("Gabriela", "Júlia", "Beatriz", "Luiza"),
  altura = c(1.59, 1.60, 1.65, 1.73),
  idade = c(30, 25, 31, 32)
)
```

E para criar uma tibble, usamos a função tribble().

```{r}
#Tibble
tibble = tribble(
  ~nome, ~altura, ~idade,
  "Gabriela", 1.59,   30,
  "Júlia",   1.60,   25,
  "Beatriz",    1.65,  31,
  "Luiza",  1.73,   32 
  )
```

**É possível transformar quase todo objeto em uma tabela.**

Por exemplo, se pegarmos os vetores criados anteriormente e usarmos a função as.data.frame(), será criada uma coluna com o nome do vetor, seguida por linhas contendo os elementos do vetor.

```{r}
# Vetores em dataframe
as.data.frame(i) #dataframe com coluna numérica
as.data.frame(j) #dataframe com coluna textual
as.data.frame(h) #dataframe com coluna textual, mesmo com valores numéricos
```

**Há diferentes formas de se visualizar uma tabela.**

A diferença de cada objeto está na visualização no console e no documento. Teste estas linhas de código no documento e no console.

```{r}
#Visualizando o dataframe -----
# Com print()
print(data) #No documento ou console
print(tibble)

# Com nome do objeto
data
tibble 

# Com glimpse(). #Descrição mais completa da tabela
glimpse(data) 
glimpse(tibble)

# Com view(). A tabela completa com mais funcionalidades (filtragem manual, pesquisa e ordenamento) abrirá em uma nova janela
view(data) 
view(tibble)

# Selecionando o nome do objeto e segurando Ctrl + Click.
data
tibble 
```

## Estatísticas gerais da tabela

O R possui uma função muito prática de análise estatística descritiva, a **summary()**.

No entanto, existem outros pacotes que realizam essas análises e até geram relatórios em HTML.

Um deles é o skimr, cuja função **skim()** gera três outputs, um semelhante ao summary, e outras duas tabelas com a quantidade de valores não disponíveis (NA), estatísticas descritivas, e um histograma.

```{r}
# Estatísticas gerais 
summary(tibble)
summary(data)

# Usando skim
skim(tibble)
skim(data)

```

## Pivotando tabelas: Long e Wide

As tabelas tidy possuem dois formatos, um largo (wide) e outro longo (long). Converter uma em outra é conhecido como **pivotagem**, e conhecer essas funções é importantíssimo para obter, manipular e explorar dados.

Para pivotar, utilizamos **pivot_longer() e pivot_wider()**. A pivotagem deve ser pensada com base na relação entre variáveis e seus valores.

Por exemplo, se tivermos uma tabela larga com 10 colunas com anos (de 1990 a 2000), podemos reduzi-las em uma só coluna chamada "anos", que facilitará a manipulação de dados. Isso alongará a tabela.

Mas, se quisermos deixá-la mais fácil de ser interpretada por humanos, podemos pivotá-la em uma tabela larga.

```{r}
# Trabalhando com dataframes -----
#Transformando outros formatos em dataframe

# Long table
data_long = pivot_longer(data, #Tabela 
             cols = c(altura, idade), #Colunas para alongar 
             values_to = "valor", # Estocar valores em uma nova coluna
             names_to = "variavel" # Estocar variáveis em uma nova coluna
             ) 
data_long
```

```{r}
# Wide table
data_wide = pivot_wider(data_long, #Tabela
            names_from = variavel, #Dividir níveis de uma coluna em novas colunas
            values_from = valor)   #Estocar valores relacionados à coluna nome e novas variáveis) 

```

## Matrizes

As matrizes são estruturas tabelares cujos valores são **somente numéricos**. Para isso, é necessário converter a coluna de "nomes" (strings) em nomes de linhas (rownames) usando o column_to_rownames(), e então converter a tabela em matriz, com o as.matrix().

A diferença aqui é a apresentação da tabela. Enquanto dataframes e tibbles são facilmente lidas, as matrizes são mais complicadas nesse sentido.

**Caso você queira manipular a matriz com as funções do tidyverse**, é recomendável reconvertê-la em dataframe/tibble, manipular os dados, e depois converter novamente para matriz.

É importante saber manipular matrizes para computar análises estatísticas, como o Principal Components Analysis, por exemplo.

```{r}
#Matriz
matrix = as.matrix(data) #Transformar tabela em matriz
matrix #Os valores numéricos são strings

data_matrix = column_to_rownames(data, "nome") #Converte coluna em rownames
matrix = as.matrix(data_matrix)
matrix #Agora, os valores são numéricos

# Reconverter para dataframe
matrix_dr = as.data.frame(matrix)

matrix_dr # Coluna "nome" continua como rownames e dificulta a manipulação.

matrix_dr = rownames_to_column(matrix_dr, "nome") #Converter rownames em nova coluna
matrix_dr

```

## Listas

Listas são estruturas que podem conter um conjunto de elementos de diferentes classes, como **vetores, outras listas, dataframes, e matrizes**.

Elas são interessantes para organizar os objetos necessários para uma análise, e são muito comuns em análises de RNAseq, por exemplo.

```{r}
#Criando a lista
lista = list(a, b, f, h, j, multi, t, data, matrix, tibble)

#View(lista) #Visualizando a lista

#Acessando objetos diferentes da lista
lista[[1]] #Primeiro objeto
lista[[8]] #Oitavo objeto

#Isolando o objeto
df_list = lista[[8]]
df_list

```

## Manipulação de tabelas com o R base

O R possui funções e formas nativas de acessar e manipular tabelas. Essas operações, como as descritas abaixo, não são mais a melhor forma de trabalhar, pois são pouco intuitivas. Mas, **é importante conhecê-las**, pois, são utilizadas em alguns casos.

```{r}
# Acessando colunas do data frame
data$nome
data$idade

# Criando nova variável para não sobrescrever a tabela original para os próximos exemplos
data_2 = data

# Adicionando uma nova coluna ao data frame
data_2$peso = c(70, 
                65, 
                80, 
                20)
data_2

# Removendo uma coluna do data frame
data_2 = data_2[ , -4]

# Filtrando linhas do data frame. df[linha, coluna]
data_jovens = data_2[data_2$idade < 30, ]
data_jovens

# Ordenando o data frame por uma coluna
data_ordenados <- data_2[order(data_2$idade), ]
data_ordenados
```

# 3. Tidyverse

O tidyverse é um **metapacote**, um pacote com diversos pacotes dentro, que facilita muito o trabalho no R. As funções conversam entre si, são padronizadas e, mais importante, são muito **intuitivas**.

## Adicionando linhas e colunas

Para adicionar uma linha com valores, usamos o add_row(), e para adicionar uma coluna, o add_column. Bem intuitivo, né?

Para não alterarmos as tabelas originais, criamos uma nova variável chamada data_2 e tibble_2.

```{r}
#Adicionar linha
data_2 = add_row(data, 
               nome = "Rafaela", 
               idade = 50,
               altura = 1.85)

tibble_2 = add_row(tibble, 
                   nome = "Rafaela", 
                   idade = 50,
                   altura = 1.85)

data_2
tibble_2
```

```{r}
#Adicionar coluna
data_2 = add_column(data_2,
                    peso = c(50,
                             80,
                             40,
                             100,
                             70))

tibble_2 = add_column(tibble_2,
                      peso = c(50,
                               80,
                               40,
                               100,
                               70))

data_2
tibble_2
```

## filter(): Filtrando linhas e usando o pipe

Sempre que estivermos manipulando linhas, utilizamos o **verbo "filtrar"**. No tidyverse, mais especificamente no pacote dplyr, usamos a função filter() e estabelecemos argumentos lógicos para a filtragem.

```{r}
# Filtrando linhas ----
idade = filter(data, idade >= 30)
idade_nome = filter(idade, nome == "Júlia")
```

Mas, e se eu quiser filtrar usando mais operações?

Temos duas formas de fazer isso.

A primeira é usando "OU" e %in% c().

```{r}
# Filtrando mais de um valor usando | (OU) e "%in% c()"
data %>%                   #Tenho este objeto
  filter(nome == "Júlia" | # E então vou filtrar indivíduos que tenham o nome "Júlia" OU 
           nome == "Gabriela") #"Gabriela"

data %>%  
  filter(nome %in% c(     # Filtrando os valores "Júlia" OU "Gabriela" dentro (%in%) da coluna "nome" 
    "Júlia", 
    "Gabriela")) 
```

E a segunda é usando o **pipe (%\>%),** que permite "costurar" operações e resultados. Dessa forma, não precisamos criar uma variável/objeto sempre que uma função for aplicada. Usaremos muito o pipe nos próximos códigos.

Abaixo, pegamos uma tabela, filtramos por idade e, então, filtramos somente linhas que não contêm um valor.

```{r}
# Usando o pipe "%>%" (lê-se "e então")
data %>%                   # Tenho este objeto 
  filter(idade >= 30) %>%  # E então vou filtrar os indivíduos com menos de 30 anos
  filter(nome != "Júlia")   # E então vou filtrar os indivíduos que não incluam a "Júlia"
```

## select(): Selecionando colunas

Da mesma forma que trabalhamos com linhas usando filter(), ao trabalhar com colunas, usamos o select().

A função select é muito versátil, e **além de selecionar colunas** que você quer trabalhar, podemos **reordená-las e renomeá-las**.

Mas, cuidado, pois ao renomeá-las, se esquecermos do "**everything()**", ficamos somente com a coluna renomeada.

Por isso, temos a função **rename()**, que evita que isso aconteça.

```{r}
# Selecionando colunas ----
# Selecionar colunas específicas
data_2 %>%
  select(nome, altura) 

# Selecionar da coluna nome (1) à coluna peso (3)
data_2 %>% 
  select(nome:peso) 

#Retirando coluna
data_2 %>% 
  select(-idade) 

data_2 %>%   
  select(!idade)

#Reordenando coluna
data_2 %>%   
  select(idade, everything())

#Renomeando coluna
data_2 %>%   
  select(age = idade, everything())

#Renomeando coluna com rename
data_2 %>%   
  rename(age = idade) #Retirando coluna

```

## mutate(): Criando e realizando operações com novas variáveis

A função mutate() permite criar ou modificar **colunas** e imputar valores usando funções que se aplicarão a todas as linhas daquela coluna.

```{r}
# Criando novas variáveis
data_2 = data_2 %>%
  mutate(imc = peso / (altura^2)) #Para cada linha da tabela, pegaremos o valor do peso e dividiremos pela altura ao quadrado.

data_2 %>% 
  mutate(sexo = "feminino") #Como todas as linhas contêm nomes femininos, criaremos a coluna sexo com o valor "feminino"

```

## summarize(): resumindo estatísticas

A função summarize (ou summarise) aplica a mesma lógica, mas a tabela gerada é muito menor, e se aplica à variável de interesse na tabela. Por exemplo, se quisermos obter a média (mean()), e a soma (sum()) das linhas de uma coluna, a summarize é capaz de fazer isso.

```{r}
# Resumindo dados
data_2 %>% 
  summarize(Media_idade = mean(idade))

data_2 %>% 
  summarize(Soma_idade = sum(idade))
```

## arrange(): Ordenando dados

```{r}
# Ordenando dados de forma crescente
data_2 %>% 
  arrange(idade)

# Ordenando de forma decrescente
#Método 1
data_2 %>% 
  arrange(desc(idade))

#Método 2
data_2 %>% 
  arrange(-idade)
```

## Usando o pipe para fazer múltiplas operações de uma vez

Usando o pipe, podemos escrever e ler códigos em uma sequência lógica fácil.

Por exemplo, abaixo:

*pegamos a tabela **data_2**, **ordenamos** a altura na ordem crescente,*

***filtramos** somente as pessoas com idade acima de 30 e peso acima de 50 e **retiramos** os nomes.*

*Depois, **arredondamos** os valores do IMC para uma casa decimal (usando round()) e **criamos uma nova variável** chamada peso versus idade.*

*Por fim, **resumimos** os dados usando a média do peso e a média do imc.*

```{r}
# Múltiplas operações em uma caixa
data_2 %>% 
  arrange(altura) %>% 
  filter(idade >= 30,
         peso >= 50) %>% 
  select(-nome) %>% 
  mutate(imc = round(imc, 1),
         peso_x_idade = peso * idade) %>%
  summarise(mean_peso = mean(peso) %>% round(1),
            mean_imc = mean(imc) %>% round(1))
```

# 4. Trabalhando com dados reais

## Importando e padronizando tabela

```{r}
#Pelo readr
cobertura_vacinal_unicef <- read_csv("cobertura_vacinal_unicef.csv") 
#Manual: File > Import Dataset > From text (readr)
cobertura_vacinal_unicef

data_long = cobertura_vacinal_unicef 
```

## Explorando dados

### Visualizando tabelas

```{r}
# Explorando dados -----

# Tabela completa
view(data_long) 

# Descrição geral
glimpse(data_long)

# Primeiras 10 linhas
head(data_long, 10)

# Últimas 10 linhas
tail(data_long, 10)

#Summary statistics
summary(data_long)
```

```{r}
#Níveis de colunas
unique(data_long$unicef_region)
unique(data_long$country)
unique(data_long$vaccine)

#Contar linhas por coluna
data_long %>% count(country) 
data_long %>% count(vaccine) 
data_long %>% count(unicef_region) 

#Tabela de frequências
table(data_long$country)
tabyl(data_long, country)
```

### Dados faltantes

```{r}
# Dados faltantes ----
skim(data_long) # Por que são faltantes? Precisamos deles?

# Como são essas linhas?
data_long %>% 
  filter(!complete.cases(.)) %>% 
  view()

```

### Padronizando tabela

Para trabalharmos de forma fácil com uma tabela, precisamos padronizá-la.

Isso significa que **trocaremos e reordenaremos os nomes das colunas** para fazerem mais sentido, completaremos os valores NA quando for possível (e fizer sentido), e explicitaremos algumas coisas, como o nome das doenças contra as quais as vacinas protegem, e daremos o nome completo de cada região, pois somente temos os códigos delas.

**No caso dos valores NA**, sabemos que certas vacinas não estavam disponíveis para todos os países ao mesmo tempo. Por isso, deixaremos como NA e não trocaremos por 0. Valores faltantes são diferentes de 0, por mais que em muitos casos possam ser trocados.

Dessa forma, utilizaremos o **if_else().** Nele, estabelecemos que, se a coluna name for igual à region, então o type será "region", caso contrário, será "country". Completaremos o mesmo com a coluna de abreviação

Além disso, na tabela original, temos dados para todos os países e continentes. Ou seja, temos uma linha chamada "Brasil" e outra chamada "Latin America", por exemplo. Sabemos que o último não é um país, então **criaremos uma coluna chamada type** usando o **if_else()** para diferenciar quando quisermos trabalhar com cada tipo.

Para dar os nomes completos das regiões e criar uma coluna das doenças relacionadas às vacinas, usamos o **case_when()**, que é um if_else() que aceita mais relações.

Assim, *quando algo for igual a algo, chame ele de algo, se algo 2 for igual a algo 2, chame ele de algo 2, ... e se isso tudo for mentira, então deixe como está.*

```{r}
# Padronizando a tabela ----

data_long_standardized = data_long %>% 
  select(name = country, 
         country_abrev = iso3, 
         year, 
         vaccine, 
         coverage = cov, 
         region = unicef_region) %>% 
  
  
  
  mutate(
         # Anotando dados
         year = as.integer(year), #Aqui, converteremos year em número inteiro, para evitar que seja lido com decimais.
         type = if_else(name == region, # Se o nome for igual à região,
                        "region",       # então ele é uma região,
                        "country"),     # caso contrário, é um país.
         
         country_abrev = if_else(name == region, # Se o nome for igual à região,
                        name,       # então ele é uma região,
                        country_abrev),     # caso contrário, é um país.
         
         region = if_else(is.na(region), 
                          name, 
                          region),
         
         # Vacinas por doenças
         diseases = case_when(vaccine == "BCG" ~ "Tuberculosis",
                              vaccine == "DTP1" ~ "Difteria, Tetanus, Pertussis",
                              vaccine == "DT3" ~ "Difteria, Tetanus, Pertussis",
                              vaccine == "HEPB3" ~ "Hepatitis B",
                              vaccine == "HEPBB" ~ "Hepatitis B",
                              vaccine == "HIB3" ~ "Haemophilus influenzae B",
                              vaccine == "IPV1" ~ "Poliomielitis",
                              vaccine == "MCV1" ~ "Measles",
                              vaccine == "MCV2" ~ "Measles",
                              vaccine == "PCV3" ~ "Pneumococcus",
                              vaccine == "POL3" ~ "Poliomielitis",
                              vaccine == "RCV1" ~ "Rotavirus",
                              vaccine == "ROTAC" ~ "Rotavirus",
                              vaccine == "YFV" ~ "Yellow fever",
                              TRUE ~ vaccine
                              ),
         
         
         # Abreviação para nome completo
         region_complete = case_when(region == "EAPR" ~ "East Asia and Pacific", 
                              region == "ECAR" ~ "Europe and Central Asia",
                              region == "MENA" ~ "Middle East and North Africa",
                              region == "ESAR" ~ "Eastern and Southern Africa",
                              region == "LACR" ~ "Latin America and Caribbean",
                              region == "Non-programme" ~ "Non-programme",
                              region == "ROSA" ~ "South Asia",
                              region == "WCAR" ~ "West and Central Africa",
                              TRUE ~ region
  ))

#Salvar tabela
data_long_standardized %>% 
  saveRDS(file = "cobertura_vacinal_unicef_padronizada.rds")

#Tabela larga
data_wide = data_long_standardized %>% 
   pivot_wider(names_from = year, 
               values_from = coverage)
```

### Unindo tabelas

```{r}
#Tabela com vacinação
data_long_standardized = readRDS(file = "cobertura_vacinal_unicef_padronizada.rds")
data_long_standardized

#Tabela com dados gerais de paises
paises_anotados = readRDS(file = "paises_anotados.rds")
paises_anotados

#Unindo tabelas
data_long_annotated = data_long_standardized %>% 
  inner_join(paises_anotados, by = "name")

glimpse(data_long_annotated) #Colunas duplicadas

data_long_annotated = data_long_standardized %>% 
  inner_join(paises_anotados %>% 
               select(-region_complete), by = "name")

glimpse(data_long_annotated)

```

```{r}
#Tabela com mortes por doenças imunopreníveis, por país, ano, sexo e idade
Deaths_infectious_diseases = readRDS(file = "Deaths_infectious_diseases.rds")
glimpse(Deaths_infectious_diseases) # mais de 2 milhões de linhas

#Reduzir tabela
Deaths_infectious_diseases_filtered = Deaths_infectious_diseases %>% 
  filter(age == "[All]",
         sex == "All") %>%  # 904 mil linhas
  select(name, year, total_deaths:death_disease) 

#Quais colunas são iguais e têm nomes diferentes?
glimpse(data_long_standardized)
glimpse(Deaths_infectious_diseases_filtered)

#Unir tabelas
data_long_annotated = data_long_annotated %>% 
    rename(disease_vac = diseases) %>% 
  left_join(Deaths_infectious_diseases_filtered,
             #by = "name") #Unir por uma coluna
             
             by = join_by(name, #Unir por mais colunas
                          year,
                          disease_vac == death_disease
                          ))

glimpse(data_long_annotated)
```

**Organizar colunas**

```{r}
#Organizar colunas
data_long_annotated = data_long_annotated %>% 
  select(type, name, country_abrev, continent, region, region_complete, year, everything())

#Salvar
data_long_annotated %>% 
  saveRDS(file = "cobertura_vacinal_anotada.rds")

```

### Estatísticas descritivas

Abaixo, queremos obter o resumo dos dados de cada país na região da América latina. Como a tabela tem linhas com dados faltantes, algumas operações podem confundir os resultados. Por isso, usamos a função drop_na().

Além disso, queremos filtrar somente os dados dos países latinoamericanos entre os anos 2000 e 2023. Para isso, usamos o between() dentro da função filter(), e especificamos que queremos o type == "country", pois também temos dados da região como um todo.

Como não queremos trabalhar com os nomes completos das regiões, podemos ser menos específicos. Por exemplo, se sabemos que existe a região "Latin America and Caribbean Region (LACR)", podemos somente usar uma função que pega um pedaço do nome completo e nos retorna aquela linha. Isso é feito com o str_detect().

Para calcularmos as estatísticas gerais com summarize, precisamos agrupar os dados com group_by. Isso porque temos dados da cobertura vacinal por país em 23 anos e para mais de uma vacina. Dessa forma, agruparemos por país (name) e vacina (vaccine). Ao final, vamos desagrupar esses dados.

**Por país**

```{r}
# Estatísticas de cada país em um continente
# Média, mediana, mínimo e máximo de uma variável numérica

latin_2000_2023 = data_long_annotated %>% 
  
  #Missing values: Aqui, é importante retirá-los para não repetir linhas
  
  drop_na(coverage) %>% 
   
  filter(between(year, 2000, 2023),
         str_detect(region_complete, "Latin"),
         type == "country") %>% 
  
  #Agrupar por vacina e país
  group_by(vaccine, name) %>% 
  
  #Resumir estatísticas
  summarise(
    mean = mean(coverage),
    median = median(coverage),
    max = max(coverage),
    min = min(coverage),
    sd = sd(coverage),
    var = var(coverage)
  ) %>% 
  
  #Desagrupar
  ungroup()

latin_2000_2023
```

**Por continente** Aqui, faremos o mesmo, mas para cada continente.

```{r}
# Cobertura vacinal: Estatísticas de cada continente
continentes_vac = data_long_annotated %>% 
  drop_na(coverage,
          continent) %>% 
  filter(between(year, 2000, 2023),
         type == "country") %>% 
  group_by(vaccine, continent) %>% 
  summarise(
    mean = mean(coverage),
    median = median(coverage),
    max = max(coverage),
    min = min(coverage),
    sd = sd(coverage),
    var = var(coverage)
  ) %>% 
  ungroup()

#Visualizar
continentes_vac
```

### Mortes cumulativas

**Por continente**

```{r}
# Mortes cumulativas
# Estatísticas de cada continente
continentes_mortes = data_long_annotated %>% 
  
  drop_na(total_deaths,
          continent) %>%
  
  filter(between(year, 2000, 2023),
         type == "country") %>% 
  
  group_by(disease_vac, continent) %>%
  
  summarise(
    cumulativo = sum(total_deaths),
    mean = mean(total_deaths),
    median = median(total_deaths),
    max = max(total_deaths),
    min = min(total_deaths),
    sd = sd(total_deaths),
    var = var(total_deaths)
  ) %>% 
  
  #Aqui, queremos os países com maior número de mortes
  arrange(disease_vac, - cumulativo) %>% 
  ungroup()

continentes_mortes
```

**Por país**

```{r}
# Mortes cumulativas
# Estatísticas de cada continente
paises_mortes = data_long_annotated %>% 
  drop_na(total_deaths,
          name) %>% 
  filter(between(year, 2000, 2023),
         type == "country") %>% 
  group_by(disease_vac, name) %>% 
  summarise(
    cumulativo = sum(total_deaths),
    mean = mean(total_deaths),
    median = median(total_deaths),
    max = max(total_deaths),
    min = min(total_deaths),
    sd = sd(total_deaths),
    var = var(total_deaths)
  ) %>% 
  arrange(disease_vac, desc(cumulativo)) %>% 
  ungroup()

paises_mortes
```

# 5. Visualização

## Vacinação

### Gráfico de pontos simples

**Por continente**

```{r}
#Gráfico de pontos simples
continentes_pontos_vac = continentes_vac %>% #Dataframe
  filter(vaccine %in% "MCV1") %>%
  mutate(continent = fct_reorder(continent, median)) %>% 
  ggplot() + #Chamando a função. Aqui se usa "+" em vez de "%>%" 
  
  #Mapeando os eixos
  aes(x = median,
      y = continent,
      color = continent) +
  
  #Geometrias
  geom_point() +
  
  geom_label(aes(x = median, 
                y = continent, 
                label = median)) +
  
  #Tema
  theme_light() +
  
  #Labels
  labs(title = "Cobertura vacinal",
       x = "Mediana (Cobertura vacinal %)",
       y = "Continentes") 

continentes_pontos_vac

```

**Por país**

```{r}
#Gráfico de pontos simples
pontos = latin_2000_2023 %>% #Dataframe
  filter(vaccine %in% "MCV1") %>%
  ggplot() + #Chamando a função. Aqui se usa "+" em vez de "%>%" 
  
  #Mapeando os eixos
  aes(x = median,
      y = name,
      color = median) +
  
  #Geometrias
  geom_point() +
  
  geom_text(aes(x = median, #Use geom_label para visualizar melhor
                y = name, 
                label = median)) +
  
  #Tema
  theme_light() +
  
  #Labels
  labs(title = "Cobertura vacinal",
       x = "Mediana (Cobertura vacinal%)",
       y = "Países")

pontos
```

### Gráfico de barras

**Por continente**

```{r}
#Gráfico de barras simples
continente_barras_vac = continentes_vac %>% #Dataframe
  filter(vaccine %in% "MCV1") %>%
  mutate(continent = fct_reorder(continent, median)) %>% 
  ggplot() + #Chamando a função. Aqui se usa "+" em vez de "%>%" 
  
  #Mapeando os eixos
  aes(x = median,
      y = continent,
      fill = continent) +
  
  #Geometrias
  geom_col() +
  
  geom_text(aes(x = median, 
                y = continent, 
                label = median)) +
  
  #Tema
  theme_light() +
  
  #Labels
  labs(title = "Cobertura vacinal",
       x = "Mediana (Cobertura vacinal %)",
       y = "Continentes") 

continente_barras_vac

```

**Por país**

```{r}
#Gráfico de barras simples
pais_barras_vac = latin_2000_2023 %>% #Dataframe
  filter(vaccine %in% "MCV1") %>%
  ggplot() + #Chamando a função. Aqui se usa "+" em vez de "%>%" 
  
  #Mapeando os eixos
  aes(x = median,
      y = name,
      fill = median) +
  
  #Geometrias
  geom_col() +
  
  geom_text(aes(x = median, 
                y = name, 
                label = median)) +
  
  #Tema
  theme_light() +
  
  #Labels
  labs(title = "Título",
       x = "Mediana (Cobertura vacinal%)",
       y = "Países")

pais_barras_vac
```

## Mortes

**Por continente**

```{r}
#Gráfico de pontos simples
barras_mortes = continentes_mortes %>% #Dataframe
  filter(disease_vac == "Measles") %>% 
  mutate(continent = fct_reorder(continent, cumulativo)) %>% 
  ggplot() + #Chamando a função. Aqui se usa "+" em vez de "%>%" 
  
  #Mapeando os eixos
  aes(x = cumulativo,
      y = continent,
      fill = continent) +
  
  #Geometrias
  geom_col() +
  
  geom_label(aes(x = cumulativo, 
                y = continent, 
                label = cumulativo),
            hjust = -0.2) +
  
  #Tema
  theme_light() +
  
  #Labels
  labs(title = "Mortes cumulativas por Sarampo, de 2000 a 2023",
       x = "Mortes",
       y = "Continentes") +
  
  #Eixo x
  xlim(0, 21000) #Aumentar limites 
  
barras_mortes 

```

```{r}

#Gráfico de pontos simples
paises_barras_mortes = paises_mortes %>% #Dataframe
  filter(disease_vac == "Measles") %>% 
  mutate(name = fct_reorder(name, cumulativo)) %>% 
  slice_max(order_by = cumulativo, n = 10) %>% 
  ggplot() + #Chamando a função. Aqui se usa "+" em vez de "%>%" 
  
  #Mapeando os eixos
  aes(x = cumulativo,
      y = name,
      fill = name) +
  
  #Geometrias
  geom_col() +
  
  geom_label(aes(x = cumulativo, 
                y = name, 
                label = cumulativo),
            hjust = -0.2) +
  
  #Tema
  theme_light() +
  
  #Labels
  labs(title = "Mortes cumulativas por Sarampo, de 2000 a 2023",
       x = "Mortes",
       y = "Continentes") +
  
  #Eixo x
  xlim(0, 21000) #Aumentar limites 
  
paises_barras_mortes
```

## Visualização rápida com o Esquisse

```{r}
#Visualização rápida
latin_2000_2023 %>% 
  esquisser() 
```

## Melhorando o gráfico

```{r}
# Melhorando o gráfico -----

plot = 
  
  # Manipular tabela
  latin_2000_2023 %>%
  filter(vaccine %in% "MCV1") %>%
  mutate(name = fct_reorder(name, median)) %>% 
 
  #Criar base do gráfico
  ggplot() +
  aes(x = median, y = name, colour = median) + #Aesthetics (mapping)
  
  #Geometria
  geom_point(shape = "circle", 
             size = 1) +
  #Highlight (add sempre após geom_)
  gghighlight(median >= 95,
              label_key = name,
              label_params = list(size = 3),
              unhighlighted_params = list(colour = "red")) +
  
  #Labels
  geom_text(aes(x = median, 
                y = name, 
                label = median),
              hjust = -0.5,
              size = 3,
              color = "black") +
  
  #Marcações
  #Linhas
  geom_vline(xintercept = 95,
             colour = "black",
             size =0.2,
             linetype = 2) +
  
  #Tema, aparência
  theme_light() + 
  
  # Labels, titulo, subtitulo, titulo dos eixos
    
  labs(title = "Vacinação em países da América Latina",
     subtitle = "Sarampo, MCV1, Dose 1, entre 2000 e 2023",
     y = "Países",
     x = "Mediana (Cobertura %)",
     tag = "Figure A.",
     colour = "Cobertura vacinal",
     caption = "Fonte: Feito pela UPVacina") +
  
  # Aparência especifica
  theme(
    
    #Texto geral
    text = element_text(family = "sans",  #sans, mono, serif
                        color = "black"), 
    
    #Título, subtítulo e tag
    plot.title = element_text(size = 12, 
                              face = "bold", 
                              hjust = 0,
                              vjust = 0.5),
    plot.subtitle = element_text(size = 10),
    plot.tag.position = "topleft",
    plot.tag = element_text(vjust = 5,
                            size = 12, 
                            face = "bold"),
    
    #Legenda
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10),
    
    #Eixos
    axis.title.x = element_text(size = 10,
                                angle = 0,
                                color = "black"),
    axis.text.x = element_text(color = "black",
                               size = 8,
                               angle = 0),
    axis.text.y = element_text(size = 8,
                               color = "black"),
    
    #Margens do gráfico
    plot.margin = unit(c(0.5, #Top
                         1, #Right
                         0.5, #Bottom
                         0), #Left 
                       "cm") #Unidade) 
  ) 
  
  #Escala de cores
  # scale_colour_manual(low = "#DC0000B2", 
  #                       high = "#4DBBD5B2",
  #                       breaks = c(90, 100)) +
  # scale_colour_steps(low = "#DC0000B2", 
  #                       high = "#4DBBD5B2")


#Visualizar
plot

#Salvar
ggsave(plot, file = "Sarampo_LatinAmerica_2000_2023.png", width = 10, height = 5)
```

## Gráfico interativo

```{r}
plot %>% 
  ggplotly() 
```

## Unindo gráficos

```{r}
#Unindo gráficos -----

vaccination = data_long_annotated %>% 
  filter(name == "Brazil",
         vaccine == "MCV1") %>% 
    ggplot() +
  geom_line(mapping = aes(
    x = year,
    y = coverage),
    colour = "#4DBBD5B2",
    linewidth = 2) +
    geom_text(aes(x = year, 
                  y = coverage, 
                  label = coverage),
            vjust = -0.5,
            size = 2) +
    theme_minimal() +
  labs(title = "Cobertura vacinal contra o sarampo, Brasil",
       x = "Ano",
       y = "Cobertura vacinal (%)") +
   ylim(0, 110)

vaccination
```

```{r}

#Mortes
deaths = data_long_annotated %>% 
  filter(name == "Brazil",
         vaccine == "MCV1") %>% 
    ggplot() +
  aes(x = year, y = total_deaths) +
  geom_col(fill = "#DC0000B2") +
  geom_text(aes(label = total_deaths),
            vjust = -0.5,
            size = 2) +
  theme_minimal() +
  theme(text = element_text(size = 10)) +
    labs(title = "Mortes por sarampo, Brasil",
       x = "Ano",
       y = "Mortes") +
   ylim(0, 3400)

deaths
```

### Unindo gráficos em uma imagem

```{r}
#Unir gráficos
(vaccination / deaths) 
(vaccination + deaths) 

#Salvar
(vaccination / deaths) %>% 
  ggsave(file = "Sarampo_Brasil_1980_2023.png", width = 10, height = 5)

```

### Boxplots

```{r}
#Boxplot simples por ano
boxplot_years = data_long_annotated %>% 
  filter(type == "country",
         vaccine == "MCV1",
         year %in% c(1990, 2000, 2010, 2019)) %>% 
  
  
 ggplot() +
  aes(x = "", 
      y = coverage, 
      fill = continent) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Set2", direction = 1) +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 45,
                                   vjust = 1,
                                   hjust = 1),
        plot.margin = unit(c(1, 1, 1, 1), "cm"),
        legend.position = "right") +
  facet_wrap(vars(year), ncol = 4) +
  labs(title = "Cobertura vacinal contra o sarampo",
       subtitle = "Primeira dose (MCV1)",
      x = "Região UNICEF",
       y = "Cobertura vacinal (%)",
       fill = "Região UNICEF")

#Visualizar
boxplot_years 
```

## Paleta de cores científica

```{r}
# Cores
#Mudando a paleta
library(ggsci)
library(scales)
vignette("ggsci") 

nrc = pal_npg("nrc", #Especificar paleta
              alpha = 0.7)(8) #Gerar 10 cores com transparencia = 70%

nrc %>% 
  show_col()

boxplot_years + scale_fill_npg()

```

```{r}
#Boxplot simples de ano
boxplot_regions = data_long_annotated %>% 
  filter(type == "country",
         vaccine == "MCV1",
         year %in% c(1990, 2000, 2010, 2020)) %>% 
  mutate(year = as.factor(year)) %>% 
 ggplot() +
  aes(x = year, y = coverage, fill = year) +
  geom_boxplot() +
  geom_jitter(aes(label = name),
              alpha = 0.2,
              na.rm = T) +
  scale_fill_brewer(palette = "Set2", direction = 1) +
  scale_color_distiller(palette = "Set2", direction = 1) +
  theme_minimal() +
  facet_wrap(vars(continent)) +
  scale_fill_npg()

boxplot_regions

```

```{r}
# Gráfico interativo
boxplot_regions %>%  
  ggplotly()
```

```{r}
#Boxplot por vacina
data_long_annotated %>% 
  filter(type == "country",
         year == 2015) %>% 
 ggplot() +
  aes(x = "", y = coverage, fill = continent) +
  geom_boxplot() +
  scale_fill_viridis_d(option = "plasma", direction = 1) +
  theme_minimal() +
  facet_wrap(vars(vaccine), 
             nrow = 1) +
  labs(x = "Regiões",
       y = "Cobertura",
       titulo = "Cobertura vacinal por região, em 2000") +
  scale_fill_lancet()  

```

## Múltiplos gráficos

```{r}
# Múltiplos gráficos ----
#Todas as linhas
data_long_standardized %>%
 filter(year >= 2012& year <= 2022) %>%
 filter(region %in% "LACR") %>%
 ggplot() +
  aes(x = year, y = coverage, color = name) +
  geom_line() +
  theme_minimal() + 
  facet_wrap(vars(vaccine), scales = "free_x") 
 
#Fica muito poluído
```

### Isolando linhas com filter()

```{r}
#Highlight linhas específicas

#Método 1
br_cov = data_long_standardized %>%
 filter(year >= 2012 & year <= 2022,
        name %in% c("Brazil", "Colombia")) %>%
 ggplot() +
  aes(x = year, 
      y = coverage,
      colour = name) +
  
  geom_line(linewidth = 2) +

  theme_minimal() +
  
  facet_wrap(vars(vaccine)) + 
  
  labs(title = "Cobertura vacinal, por vacina",
       x = "Ano",
       y = "Cobertura (%)")  +
  
  scale_color_npg() 

br_cov 
```

### Isolando linhas com gghighlight()

```{r}
#Método 2
br_cov = data_long_standardized %>%
 filter(year >= 2012 & year <= 2022,
        region %in% c("LACR")) %>%
 ggplot() +
  
  geom_line(aes(x = year, 
      y = coverage,
      colour = name),
      linewidth = 2) +

  theme_minimal() +
  
  theme(axis.text.x = element_text(angle = 90)) +
  
  facet_wrap(vars(vaccine)) + 
  
  labs(title = "Cobertura vacinal, por vacina",
       x = "Ano",
       y = "Cobertura (%)") +
  
  gghighlight(name %in% c("Brazil", "Colombia"), 
              calculate_per_facet = T, #Add quando tiver facets
              unhighlighted_params = list(linewidth = 1, 
                                          colour = "gray90", 
                                          alpha = 0.3)) +
  scale_color_npg() 

br_cov
```

```{r}
#Mortes
br_mortes = data_long_annotated %>%
 filter(year >= 2012 & year <= 2022,
        region %in% c("LACR")) %>% 
  select(name, year, total_deaths, death_rate_100thousand, disease_vac) %>% 
  distinct() %>%
  drop_na(total_deaths) %>% 
 ggplot() +
  geom_line(aes(x = round(year, 0), 
      y = total_deaths,
      colour = name),
      linewidth = 2) +

  theme_minimal() +
  
  facet_wrap(vars(disease_vac), 
             scales = "free", 
             nrow = 3) + 
  
  labs(title = "Mortes por doença imunoprevenível",
       x = "Ano",
       y = "Mortes") +
  
  #highlight
  gghighlight(name %in% c("Brazil", "Colombia"), #Linhas somente com name == "Brazil'
              
              calculate_per_facet = T, #Add quando tiver facets
              
              unhighlighted_params = list(linewidth = 1, #Opções para linhas não marcadas
                                          colour = "gray90", 
                                          alpha = 0.5)) + 
  scale_color_npg() 

br_mortes 

  
```

```{r}
# Unir gráficos
ggsave(br_cov + br_mortes, file = "br_cov_mortes.png") 
```

# 6. Modelo

Este modelo é útil para você criar gráficos de forma mais fácil, considerando as layers, funções e argumentos mais utilizados no ggplot. Caso queira gerar outros tipos de gráficos, use diferentes geometrias e consulte o (R graph gallery)[<https://r-graph-gallery.com/>].

```{r}

# Gráfico com pontos -------

# Filtrar tabela
latin_2000_2023 %>%
  filter(vaccine %in% c("MCV1")) %>%
  mutate(name = fct_reorder(name, median)) %>% 
 
  #Criar base do gráfico
  ggplot() +
  aes(x = , 
      y = , 
      colour = ) + #Aesthetics (o que cada elemento representa)
  
  #Geometria
  geom_point(shape = "circle", 
             size = 1) + 
  
  geom_text(aes(y = )) +
  
  #Tema, aparência
  theme_light() + 
  
  #Escala de cores
  scale_colour_gradient(low = "#DC0000B2", 
                        high = "#4DBBD5B2") + 
  
  # Labels, titulo, subtitulo, titulo dos eixos
  labs(
     title = "",
     subtitle = "",
     y = "",
     x = "",
     tag = "",
     caption = "Fonte:") +
  
  # Aparência especifica
  theme(
    
    #Texto geral
    text = element_text(family = "", 
                        color = ""), 
    
    #Título, subtítulo e tag
    plot.title = element_text(size = 12, 
                              face = "bold", 
                              hjust = 0,
                              vjust = 0.5),
    plot.subtitle = element_text(size = 10),
    plot.tag.position = "topleft",
    plot.tag = element_text(vjust = 5,
                            size = 12, 
                            face = "bold"),
    #Eixos
    axis.title.x = element_text(size = 10,
                                angle = 0,
                                color = "black"),
    axis.text.x = element_text(color = "black",
                               size = 8,
                               angle = 90),
    axis.text.y = element_text(size = 8,
                               color = "black"),
    
    #Margens do gráfico
    plot.margin = unit(c(0, #Top
                         0, #Right
                         0, #Bottom
                         0), #Left 
                       "cm") #Unidade) 
  ) +
  
  #Marcações
  #Linhas
  geom_hline(yintercept = "Brazil", 
             colour = "blue") +
  geom_hline(yintercept = "Haiti", 
              colour = "red") +
  geom_vline(xintercept = 95,
             colour = "black",
             size = 1,
             linetype = 1
             ) 

```

# Analisando a distribuição

Quantos países por continente registraram os dados na UNICEF?

```{r}
#Quantos países por continente registraram os dados na UNICEF?

#Todos os continentes juntos
data_long_annotated %>%
 filter(type == "country",
        continent != "Other") %>% 
 select(coverage, year, continent, vaccine) %>% 
 drop_na(coverage) %>% 
 ggplot() +
  aes(x = year, fill = continent) +
  geom_histogram(bins = 43L) +
  theme_minimal() +
  facet_wrap(vars(vaccine)) +
  scale_fill_npg()
```

Continentes separados

```{r}
# Continentes separados
data_long_annotated %>%
 filter(type == "country",
        continent != "Other") %>% 
 select(coverage, year, continent, vaccine) %>% 
 drop_na(coverage) %>% 
 ggplot() +
  aes(x = year, fill = continent) +
  geom_histogram(bins = 43L) +
  scale_fill_hue(direction = 1) +
  theme_minimal() +
  facet_grid(continent ~ vaccine, scales = "free")
```

Quantos países aumentaram sua cobertura vacinal em cada decada?

```{r}
#Quantos países aumentaram sua cobertura vacinal em cada decada?

data_long_annotated %>%
 filter(type == "country",
        continent != "Other",
        year %in% c(1990, 2000, 2010, 2019)) %>%
 ggplot() +
  aes(x = coverage, fill = continent) +
  geom_histogram(bins = 10L) +
  theme_minimal() +
  theme(plot.caption = element_text(size = 13L),
        legend.position = "top",
        strip.text.y = element_text(angle = 0, 
                                    hjust = 0)) +
  facet_grid(~disease_vac~year, scales = "free") +
  facet_grid(continent ~ vaccine, scales = "free")

```

# Avançado: Dados demográficos e economicos com o Gapminder

O gapminder é um site e um pacote que apresenta diferentes dados sobre países ao longo dos anos. O pacote do R traz uma tabela dos anos 50 até 2007, com dados sobre expectativa de vida, PIB percapita e tamanho da população.

```{r}
install.packages("gapminder")
library(gapminder)

gapminder %>% 
  filter(year %in% c(1952, 1982, 2002)) %>% 
ggplot() +
  aes(
    x = gdpPercap,
    y = lifeExp,
    colour = continent,
    size = pop,
    group = country
  ) +
  geom_point(shape = "circle") +
  scale_x_continuous(trans = "log10") +
  theme_minimal() +
  facet_wrap(vars(year), scales = "free_x") +
  gghighlight(country == "China") +
  scale_color_npg()
```

# Mudando a fonte

```{r}
# Mudando a fonte
font_add_google("Montserrat", # Importe a fonte Montserrat
                "montserrat") # como "montserrat"
#showtext_auto() #Inicializar fonte
# showtext_opts(dpi = 300) #Manter qualidade ao salvar gráfico

```
